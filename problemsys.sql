/*
 Navicat Premium Data Transfer

 Source Server         : LocaMySQL
 Source Server Type    : MySQL
 Source Server Version : 50719
 Source Host           : localhost:3306
 Source Schema         : problemsys

 Target Server Type    : MySQL
 Target Server Version : 50719
 File Encoding         : 65001

 Date: 08/12/2020 22:13:45
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for answer
-- ----------------------------
DROP TABLE IF EXISTS `answer`;
CREATE TABLE `answer`  (
  `answer_id` int(10) NOT NULL AUTO_INCREMENT,
  `problem_id` int(10) NOT NULL,
  `answer_user_id` int(10) NOT NULL,
  `problem_answer` varchar(5000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `answer_score` int(3) NULL DEFAULT NULL,
  `answer_date` datetime(0) NOT NULL,
  `answer_likes` int(255) NOT NULL,
  PRIMARY KEY (`answer_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of answer
-- ----------------------------
INSERT INTO `answer` VALUES (1, 1, 1, '&lt;h3&gt;解题思路&lt;/h3&gt;&lt;p&gt;这个应该很容易就想到，&lt;code&gt;runningSum&lt;/code&gt;其实就是一个累加序列，&lt;code&gt;runningSum[i] = nums[0] + nums[1] + ... + nums[i]&lt;/code&gt;，其实就是数学中的求和数列的概念。因此，在这里利用一个递推&lt;code&gt;runningSum[i] = runningSum[i-1] + nums[i]&lt;/code&gt;即可一个for循环搞定。&lt;br&gt;时间复杂度： O(n), 空间复杂度:O(n)&lt;br&gt;所以这里可以再优化一下，事实上在计算&lt;code&gt;runningSum[i]&lt;/code&gt;的时候，&lt;code&gt;nums[0...n-1]&lt;/code&gt;已经没有用了，除了要拿出来&lt;code&gt;nums[i]&lt;/code&gt;算一遍，因此&lt;code&gt;runningSum&lt;/code&gt;数组可以直接存放在&lt;code&gt;nums&lt;/code&gt;数组中，最终代码如下&lt;/p&gt;&lt;h3&gt;代码&lt;/h3&gt;&lt;pre&gt;&lt;button title=\"复制代码\"&gt;&lt;i&gt;&lt;/i&gt;&lt;/button&gt;&lt;code&gt;class Solution {\n    public int[] runningSum(int[] nums) {\n        int len = nums.length;\n        for (int i = 1; i &amp;lt; len; i++)\n            nums[i] = nums[i-1] + nums[i];\n        return nums;\n    }\n}&lt;/code&gt;&lt;/pre&gt;', 100, '2020-12-08 16:25:57', 134);
INSERT INTO `answer` VALUES (2, 1, 1, '实施十四', 12, '2020-12-08 17:15:30', 21);
INSERT INTO `answer` VALUES (3, 1, 2, 'a阿三大苏打实打实', 11, '2020-12-08 19:03:20', 10);
INSERT INTO `answer` VALUES (9, 1, 1, '&lt;p&gt;测试测试测试 测试测试测试测试测试测试&amp;nbsp;&lt;/p&gt;', NULL, '2020-12-08 16:34:11', 10);
INSERT INTO `answer` VALUES (10, 1, 2, '&lt;p&gt;哈哈哈&lt;/p&gt;', NULL, '2020-12-08 17:29:24', 9);
INSERT INTO `answer` VALUES (11, 1, 2, '&lt;p&gt;测试测试测试&lt;/p&gt;', NULL, '2020-12-08 18:04:05', 0);

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `comment_id` int(10) NOT NULL AUTO_INCREMENT,
  `comment_content` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `comment_user_id` int(10) NOT NULL,
  `comment_date` datetime(0) NULL DEFAULT NULL,
  `answer_id` int(10) NOT NULL,
  PRIMARY KEY (`comment_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (1, '妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙妙', 1, '2020-12-08 16:41:30', 1);
INSERT INTO `comment` VALUES (2, '&lt;p&gt;好得很 好得很好得很好得很好得很&amp;nbsp;&lt;/p&gt;', 1, '2020-12-08 17:20:05', 9);
INSERT INTO `comment` VALUES (3, '&lt;p&gt;哈哈哈哈哈哈哈哈哈哈哈&lt;/p&gt;', 1, '2020-12-08 21:54:01', 2);

-- ----------------------------
-- Table structure for problem
-- ----------------------------
DROP TABLE IF EXISTS `problem`;
CREATE TABLE `problem`  (
  `problem_id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `problem_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `problem_content` varchar(5000) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `problem_date` datetime(0) NOT NULL,
  `problem_user_id` int(10) NOT NULL,
  PRIMARY KEY (`problem_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 31 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of problem
-- ----------------------------
INSERT INTO `problem` VALUES (1, '一维动态数组和', '&lt;p&gt;给你一个数组&amp;nbsp;&lt;code&gt;nums&lt;/code&gt;&amp;nbsp;。数组「动态和」的计算公式为：&lt;code&gt;runningSum[i] = sum(nums[0]…nums[i])&lt;/code&gt;&amp;nbsp;。&lt;/p&gt;&lt;p&gt;请返回&amp;nbsp;&lt;code&gt;nums&lt;/code&gt;&amp;nbsp;的动态和。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;nums = [1,2,3,4]\n&lt;strong&gt;输出：&lt;/strong&gt;[1,3,6,10]\n&lt;strong&gt;解释：&lt;/strong&gt;动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;nums = [1,1,1,1,1]\n&lt;strong&gt;输出：&lt;/strong&gt;[1,2,3,4,5]\n&lt;strong&gt;解释：&lt;/strong&gt;动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。&lt;/pre&gt;', '2020-12-08 16:24:49', 1);
INSERT INTO `problem` VALUES (2, ' 替换空格', '请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。\r\n\r\n示例 1：\r\n\r\n输入：s = \"We are happy.\"\r\n输出：\"We%20are%20happy.\"', '2020-11-17 07:48:58', 1);
INSERT INTO `problem` VALUES (3, '二叉树的深度', '输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。', '2020-11-27 17:11:01', 1);
INSERT INTO `problem` VALUES (4, ' 从尾到头打印链表', '输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。     示例 1：  输入：head = [1,3,2] 输出：[2,3,1]', '2020-11-27 17:12:35', 1);
INSERT INTO `problem` VALUES (5, '合并两个排序的链表', '输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。\r\n\r\n示例1：\r\n\r\n输入：1->2->4, 1->3->4\r\n输出：1->1->2->3->4->4', '2020-11-27 17:13:25', 1);
INSERT INTO `problem` VALUES (6, '斐波那契数列', '写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：\r\n\r\nF(0) = 0,   F(1) = 1\r\nF(N) = F(N - 1) + F(N - 2), 其中 N > 1.\r\n斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。', '2020-11-27 17:14:59', 1);
INSERT INTO `problem` VALUES (7, '连续子数组的最大和', '输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。\r\n\r\n要求时间复杂度为O(n)。\r\n\r\n \r\n\r\n示例1:\r\n\r\n输入: nums = [-2,1,-3,4,-1,2,1,-5,4]\r\n输出: 6\r\n解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。', '2020-11-27 17:15:21', 1);
INSERT INTO `problem` VALUES (9, '杨辉三角', '&lt;p&gt;给定一个非负整数&amp;nbsp;&lt;em&gt;numRows，&lt;/em&gt;生成杨辉三角的前&amp;nbsp;&lt;em&gt;numRows&amp;nbsp;&lt;/em&gt;行。&lt;/p&gt;&lt;p&gt;&lt;img src=\"https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif\" alt=\"\"&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;在杨辉三角中，每个数是它左上方和右上方的数的和。&lt;/small&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;&lt;/small&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt; 5\n&lt;strong&gt;输出:&lt;/strong&gt;\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]&lt;/pre&gt;', '2020-12-06 21:40:47', 1);
INSERT INTO `problem` VALUES (10, '宝石与石头', '&lt;p&gt;&amp;nbsp;给定字符串&lt;code&gt;J&lt;/code&gt;&amp;nbsp;代表石头中宝石的类型，和字符串&amp;nbsp;&lt;code&gt;S&lt;/code&gt;代表你拥有的石头。&amp;nbsp;&lt;code&gt;S&lt;/code&gt;&amp;nbsp;中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。&lt;/p&gt;&lt;p&gt;&lt;code&gt;J&lt;/code&gt;&amp;nbsp;中的字母不重复，&lt;code&gt;J&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;S&lt;/code&gt;中的所有字符都是字母。字母区分大小写，因此&lt;code&gt;\"a\"&lt;/code&gt;和&lt;code&gt;\"A\"&lt;/code&gt;是不同类型的石头。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt; J = \"aA\", S = \"aAAbbbb\"\n&lt;strong&gt;输出:&lt;/strong&gt; 3\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt; J = \"z\", S = \"ZZ\"\n&lt;strong&gt;输出:&lt;/strong&gt; 0\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;S&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;J&lt;/code&gt;&amp;nbsp;最多含有50个字母。&lt;/li&gt;&lt;li&gt;&amp;nbsp;&lt;code&gt;J&lt;/code&gt;&amp;nbsp;中的字符不重复。&lt;/li&gt;&lt;/ul&gt;', '2020-12-06 21:43:22', 1);
INSERT INTO `problem` VALUES (11, '最小路径和', '&lt;p&gt;给定一个包含非负整数的&amp;nbsp;&lt;code&gt;&lt;em&gt;m&lt;/em&gt;&amp;nbsp;x&amp;nbsp;&lt;em&gt;n&lt;/em&gt;&lt;/code&gt;&amp;nbsp;网格&amp;nbsp;&lt;code&gt;grid&lt;/code&gt;&amp;nbsp;，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;每次只能向下或者向右移动一步。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=\"https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg\" alt=\"\"&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;grid = [[1,3,1],[1,5,1],[4,2,1]]\n&lt;strong&gt;输出：&lt;/strong&gt;7\n&lt;strong&gt;解释：&lt;/strong&gt;因为路径 1→3→1→1→1 的总和最小。\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;grid = [[1,2,3],[4,5,6]]\n&lt;strong&gt;输出：&lt;/strong&gt;12\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;m == grid.length&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;n == grid[i].length&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;0 &amp;lt;= grid[i][j] &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;', '2020-12-06 21:44:29', 1);
INSERT INTO `problem` VALUES (12, '钥匙和房间', '&lt;p&gt;有&amp;nbsp;&lt;code&gt;N&lt;/code&gt;&amp;nbsp;个房间，开始时你位于&amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;号房间。每个房间有不同的号码：&lt;code&gt;0，1，2，...，N-1&lt;/code&gt;，并且房间里可能有一些钥匙能使你进入下一个房间。&lt;/p&gt;&lt;p&gt;在形式上，对于每个房间&amp;nbsp;&lt;code&gt;i&lt;/code&gt;&amp;nbsp;都有一个钥匙列表&amp;nbsp;&lt;code&gt;rooms[i]&lt;/code&gt;，每个钥匙&amp;nbsp;&lt;code&gt;rooms[i][j]&lt;/code&gt;&amp;nbsp;由&amp;nbsp;&lt;code&gt;[0,1，...，N-1]&lt;/code&gt;&amp;nbsp;中的一个整数表示，其中&amp;nbsp;&lt;code&gt;N = rooms.length&lt;/code&gt;。 钥匙&amp;nbsp;&lt;code&gt;rooms[i][j] = v&lt;/code&gt;&amp;nbsp;可以打开编号为&amp;nbsp;&lt;code&gt;v&lt;/code&gt;&amp;nbsp;的房间。&lt;/p&gt;&lt;p&gt;最初，除&amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;号房间外的其余所有房间都被锁住。&lt;/p&gt;&lt;p&gt;你可以自由地在房间之间来回走动。&lt;/p&gt;&lt;p&gt;如果能进入每个房间返回&amp;nbsp;&lt;code&gt;true&lt;/code&gt;，否则返回&amp;nbsp;&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;ol&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入: &lt;/strong&gt;[[1],[2],[3],[]]\n&lt;strong&gt;输出: &lt;/strong&gt;true\n&lt;strong&gt;解释:  &lt;/strong&gt;\n我们从 0 号房间开始，拿到钥匙 1。\n之后我们去 1 号房间，拿到钥匙 2。\n然后我们去 2 号房间，拿到钥匙 3。\n最后我们去了 3 号房间。\n由于我们能够进入每个房间，我们返回 true。\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;[[1,3],[3,0,1],[2],[0]]\n&lt;strong&gt;输出：&lt;/strong&gt;false\n&lt;strong&gt;解释：&lt;/strong&gt;我们不能进入 2 号房间。&lt;/pre&gt;', '2020-12-06 21:45:01', 1);
INSERT INTO `problem` VALUES (13, '有效括号的嵌套深度', '&lt;p&gt;&lt;strong&gt;有效括号字符串&amp;nbsp;&lt;/strong&gt;定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「&lt;strong&gt;有效括号字符串&lt;/strong&gt;」部分。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;嵌套深度&lt;/strong&gt;&amp;nbsp;&lt;code&gt;depth&lt;/code&gt;&amp;nbsp;定义：即有效括号字符串嵌套的层数，&lt;code&gt;depth(A)&lt;/code&gt;&amp;nbsp;表示有效括号字符串&amp;nbsp;&lt;code&gt;A&lt;/code&gt;&amp;nbsp;的嵌套深度。详情参见题末「&lt;strong&gt;嵌套深度&lt;/strong&gt;」部分。&lt;/p&gt;&lt;p&gt;有效括号字符串类型与对应的嵌套深度计算方法如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/01/1111.png\" alt=\"\"&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;给你一个「有效括号字符串」&amp;nbsp;&lt;code&gt;seq&lt;/code&gt;，请你将其分成两个不相交的有效括号字符串，&lt;code&gt;A&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;B&lt;/code&gt;，并使这两个字符串的深度最小。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不相交：每个&amp;nbsp;&lt;code&gt;seq[i]&lt;/code&gt;&amp;nbsp;只能分给&amp;nbsp;&lt;code&gt;A&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;B&lt;/code&gt;&amp;nbsp;二者中的一个，不能既属于&amp;nbsp;&lt;code&gt;A&lt;/code&gt;&amp;nbsp;也属于&amp;nbsp;&lt;code&gt;B&lt;/code&gt;&amp;nbsp;。&lt;/li&gt;&lt;li&gt;&lt;code&gt;A&lt;/code&gt;&amp;nbsp;或&amp;nbsp;&lt;code&gt;B&lt;/code&gt;&amp;nbsp;中的元素在原字符串中可以不连续。&lt;/li&gt;&lt;li&gt;&lt;code&gt;A.length + B.length = seq.length&lt;/code&gt;&lt;/li&gt;&lt;li&gt;深度最小：&lt;code&gt;max(depth(A), depth(B))&lt;/code&gt;&amp;nbsp;的可能取值最小。&amp;nbsp;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;划分方案用一个长度为&amp;nbsp;&lt;code&gt;seq.length&lt;/code&gt;&amp;nbsp;的答案数组&amp;nbsp;&lt;code&gt;answer&lt;/code&gt;&amp;nbsp;表示，编码规则如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;answer[i] = 0&lt;/code&gt;，&lt;code&gt;seq[i]&lt;/code&gt;&amp;nbsp;分给&amp;nbsp;&lt;code&gt;A&lt;/code&gt;&amp;nbsp;。&lt;/li&gt;&lt;li&gt;&lt;code&gt;answer[i] = 1&lt;/code&gt;，&lt;code&gt;seq[i]&lt;/code&gt;&amp;nbsp;分给&amp;nbsp;&lt;code&gt;B&lt;/code&gt;&amp;nbsp;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果存在多个满足要求的答案，只需返回其中任意&amp;nbsp;&lt;strong&gt;一个&amp;nbsp;&lt;/strong&gt;即可。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;seq = \"(()())\"\n&lt;strong&gt;输出：&lt;/strong&gt;[0,1,1,1,1,0]&lt;/pre&gt;', '2020-12-06 21:45:31', 1);
INSERT INTO `problem` VALUES (14, '找出给定方程的正整数解', '&lt;p&gt;给你一个函数&amp;nbsp;&amp;nbsp;&lt;code&gt;f(x, y)&lt;/code&gt;&amp;nbsp;和一个目标结果&amp;nbsp;&lt;code&gt;z&lt;/code&gt;，请你计算方程&amp;nbsp;&lt;code&gt;f(x,y) == z&lt;/code&gt;&amp;nbsp;所有可能的正整数&amp;nbsp;&lt;strong&gt;数对&lt;/strong&gt;&amp;nbsp;&lt;code&gt;x&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;y&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;给定函数是严格单调的，也就是说：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;f(x, y) &amp;lt; f(x + 1, y)&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;f(x, y) &amp;lt; f(x, y + 1)&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;函数接口定义如下：&lt;/p&gt;&lt;pre&gt;interface CustomFunction {\npublic:\n&amp;nbsp; // Returns positive integer f(x, y) for any given positive integer x and y.\n&amp;nbsp; int f(int x, int y);\n};\n&lt;/pre&gt;&lt;p&gt;如果你想自定义测试，你可以输入整数&amp;nbsp;&lt;code&gt;function_id&lt;/code&gt;&amp;nbsp;和一个目标结果&amp;nbsp;&lt;code&gt;z&lt;/code&gt;&amp;nbsp;作为输入，其中&amp;nbsp;&lt;code&gt;function_id&lt;/code&gt;&amp;nbsp;表示一个隐藏函数列表中的一个函数编号，题目只会告诉你列表中的&amp;nbsp;&lt;code&gt;2&lt;/code&gt;&amp;nbsp;个函数。 &amp;nbsp;&lt;/p&gt;&lt;p&gt;你可以将满足条件的&amp;nbsp;&lt;strong&gt;结果数对&lt;/strong&gt;&amp;nbsp;按任意顺序返回。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;function_id = 1, z = 5\n&lt;strong&gt;输出：&lt;/strong&gt;[[1,4],[2,3],[3,2],[4,1]]\n&lt;strong&gt;解释：&lt;/strong&gt;function_id = 1 表示 f(x, y) = x + y&lt;/pre&gt;', '2020-12-06 21:48:21', 1);
INSERT INTO `problem` VALUES (15, '区域和检索 - 数组不可变', '&lt;p&gt;给定一个整数数组 &amp;nbsp;&lt;code&gt;nums&lt;/code&gt;，求出数组从索引&amp;nbsp;&lt;code&gt;i&lt;/code&gt;&lt;em&gt;&amp;nbsp;&lt;/em&gt;到&amp;nbsp;&lt;code&gt;j&lt;/code&gt;&lt;em&gt;（&lt;/em&gt;&lt;code&gt;i&amp;nbsp;≤&amp;nbsp;j&lt;/code&gt;）范围内元素的总和，包含&amp;nbsp;&lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&amp;nbsp;&lt;/code&gt;两点。&lt;/p&gt;&lt;div&gt;&lt;div&gt;&lt;p&gt;实现&amp;nbsp;&lt;code&gt;NumArray&lt;/code&gt;&amp;nbsp;类：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;NumArray(int[] nums)&lt;/code&gt;&amp;nbsp;使用数组&amp;nbsp;&lt;code&gt;nums&lt;/code&gt;&amp;nbsp;初始化对象&lt;/li&gt;&lt;li&gt;&lt;code&gt;int sumRange(int i, int j)&lt;/code&gt;&amp;nbsp;返回数组&amp;nbsp;&lt;code&gt;nums&lt;/code&gt;&amp;nbsp;从索引&amp;nbsp;&lt;code&gt;i&lt;/code&gt;&lt;em&gt;&amp;nbsp;&lt;/em&gt;到&amp;nbsp;&lt;code&gt;j&lt;/code&gt;&lt;em&gt;（&lt;/em&gt;&lt;code&gt;i&amp;nbsp;≤&amp;nbsp;j&lt;/code&gt;）范围内元素的总和，包含&amp;nbsp;&lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&amp;nbsp;&lt;/code&gt;两点（也就是&amp;nbsp;&lt;code&gt;sum(nums[i], nums[i + 1], ... , nums[j])&lt;/code&gt;）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\n&lt;strong&gt;输出：\n&lt;/strong&gt;[null, 1, -1, -3]\n\n&lt;strong&gt;解释：&lt;/strong&gt;\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)\nnumArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) \nnumArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;', '2020-12-06 22:13:23', 1);
INSERT INTO `problem` VALUES (16, '二叉搜索树的最近公共祖先', '&lt;p&gt;给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。&lt;/p&gt;&lt;p&gt;&lt;a href=\"https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin\"&gt;百度百科&lt;/a&gt;中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（&lt;strong&gt;一个节点也可以是它自己的祖先&lt;/strong&gt;）。”&lt;/p&gt;&lt;p&gt;例如，给定如下二叉搜索树:&amp;nbsp; root =&amp;nbsp;[6,2,8,0,4,7,9,null,null,3,5]&lt;/p&gt;&lt;p&gt;&lt;img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png\" alt=\"\"&gt;&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt; root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n&lt;strong&gt;输出:&lt;/strong&gt; 6 \n&lt;strong&gt;解释: &lt;/strong&gt;节点 &lt;code&gt;2 &lt;/code&gt;和节点 &lt;code&gt;8 &lt;/code&gt;的最近公共祖先是 &lt;code&gt;6。&lt;/code&gt;&lt;/pre&gt;', '2020-12-06 22:13:49', 1);
INSERT INTO `problem` VALUES (17, '二维区域和检索 - 矩阵不可变', '&lt;p&gt;给定一个二维矩阵，计算其子矩形范围内元素的总和，该子矩阵的左上角为 (&lt;em&gt;row&lt;/em&gt;1,&amp;nbsp;&lt;em&gt;col&lt;/em&gt;1) ，右下角为 (&lt;em&gt;row&lt;/em&gt;2,&amp;nbsp;&lt;em&gt;col&lt;/em&gt;2)。&lt;/p&gt;&lt;p&gt;&lt;img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/images/304.png\" alt=\"Range Sum Query 2D\"&gt;&lt;br&gt;&lt;small&gt;上图子矩阵左上角&amp;nbsp;(row1, col1) =&amp;nbsp;&lt;strong&gt;(2, 1)&lt;/strong&gt;&amp;nbsp;，右下角(row2, col2) =&amp;nbsp;&lt;strong&gt;(4, 3)，&lt;/strong&gt;该子矩形内元素的总和为 8。&lt;/small&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;给定 matrix = [\n  [3, 0, 1, 4, 2],\n  [5, 6, 3, 2, 1],\n  [1, 2, 0, 1, 5],\n  [4, 1, 0, 1, 7],\n  [1, 0, 3, 0, 5]\n]\n\nsumRegion(2, 1, 4, 3) -&amp;gt; 8\nsumRegion(1, 1, 2, 2) -&amp;gt; 11\nsumRegion(1, 2, 2, 4) -&amp;gt; 12&lt;/pre&gt;', '2020-12-06 22:14:03', 1);
INSERT INTO `problem` VALUES (18, '掷骰子的N种方法', '&lt;p&gt;这里有&amp;nbsp;&lt;code&gt;d&lt;/code&gt;&amp;nbsp;个一样的骰子，每个骰子上都有&amp;nbsp;&lt;code&gt;f&lt;/code&gt;&amp;nbsp;个面，分别标号为&amp;nbsp;&lt;code&gt;1, 2, ..., f&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。&lt;/p&gt;&lt;p&gt;如果需要掷出的总点数为&amp;nbsp;&lt;code&gt;target&lt;/code&gt;，请你计算出有多少种不同的组合情况（所有的组合情况总共有&amp;nbsp;&lt;code&gt;f^d&lt;/code&gt;&amp;nbsp;种），&lt;strong&gt;模&amp;nbsp;&lt;code&gt;10^9 + 7&lt;/code&gt;&lt;/strong&gt;&amp;nbsp;后返回。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;d = 1, f = 6, target = 3\n&lt;strong&gt;输出：&lt;/strong&gt;1\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;d = 2, f = 6, target = 7\n&lt;strong&gt;输出：&lt;/strong&gt;6\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 3：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;d = 2, f = 5, target = 10\n&lt;strong&gt;输出：&lt;/strong&gt;1&lt;/pre&gt;', '2020-12-06 22:14:18', 1);
INSERT INTO `problem` VALUES (19, '速算机器人', '&lt;p&gt;小扣在秋日市集发现了一款速算机器人。店家对机器人说出两个数字（记作&amp;nbsp;&lt;code&gt;x&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;y&lt;/code&gt;），请小扣说出计算指令：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;\"A\"&lt;/code&gt;&amp;nbsp;运算：使&amp;nbsp;&lt;code&gt;x = 2 * x + y&lt;/code&gt;；&lt;/li&gt;&lt;li&gt;&lt;code&gt;\"B\"&lt;/code&gt;&amp;nbsp;运算：使&amp;nbsp;&lt;code&gt;y = 2 * y + x&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在本次游戏中，店家说出的数字为&amp;nbsp;&lt;code&gt;x = 1&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;y = 0&lt;/code&gt;，小扣说出的计算指令记作仅由大写字母&amp;nbsp;&lt;code&gt;A&lt;/code&gt;、&lt;code&gt;B&lt;/code&gt;&amp;nbsp;组成的字符串&amp;nbsp;&lt;code&gt;s&lt;/code&gt;，字符串中字符的顺序表示计算顺序，请返回最终&amp;nbsp;&lt;code&gt;x&lt;/code&gt;&amp;nbsp;与&amp;nbsp;&lt;code&gt;y&lt;/code&gt;&amp;nbsp;的和为多少。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;输入：&lt;code&gt;s = \"AB\"&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出：&lt;code&gt;4&lt;/code&gt;&lt;/p&gt;&lt;p&gt;解释：&lt;br&gt;经过一次 A 运算后，x = 2, y = 0。&lt;br&gt;再经过一次 B 运算，x = 2, y = 2。&lt;br&gt;最终 x 与 y 之和为 4。&lt;/p&gt;&lt;/blockquote&gt;', '2020-12-06 22:15:02', 1);
INSERT INTO `problem` VALUES (20, '早餐组合', '&lt;p&gt;小扣在秋日市集选择了一家早餐摊位，一维整型数组&amp;nbsp;&lt;code&gt;staple&lt;/code&gt;&amp;nbsp;中记录了每种主食的价格，一维整型数组&amp;nbsp;&lt;code&gt;drinks&lt;/code&gt;&amp;nbsp;中记录了每种饮料的价格。小扣的计划选择一份主食和一款饮料，且花费不超过&amp;nbsp;&lt;code&gt;x&lt;/code&gt;&amp;nbsp;元。请返回小扣共有多少种购买方案。&lt;/p&gt;&lt;p&gt;注意：答案需要以&amp;nbsp;&lt;code&gt;1e9 + 7 (1000000007)&lt;/code&gt;&amp;nbsp;为底取模，如：计算初始结果为：&lt;code&gt;1000000008&lt;/code&gt;，请返回&amp;nbsp;&lt;code&gt;1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;输入：&lt;code&gt;staple = [10,20,5], drinks = [5,5,2], x = 15&lt;/code&gt;&lt;/p&gt;&lt;p&gt;输出：&lt;code&gt;6&lt;/code&gt;&lt;/p&gt;&lt;p&gt;解释：小扣有 6 种购买方案，所选主食与所选饮料在数组中对应的下标分别是：&lt;br&gt;第 1 种方案：staple[0] + drinks[0] = 10 + 5 = 15；&lt;br&gt;第 2 种方案：staple[0] + drinks[1] = 10 + 5 = 15；&lt;br&gt;第 3 种方案：staple[0] + drinks[2] = 10 + 2 = 12；&lt;br&gt;第 4 种方案：staple[2] + drinks[0] = 5 + 5 = 10；&lt;br&gt;第 5 种方案：staple[2] + drinks[1] = 5 + 5 = 10；&lt;br&gt;第 6 种方案：staple[2] + drinks[2] = 5 + 2 = 7。&lt;/p&gt;&lt;/blockquote&gt;', '2020-12-06 22:15:21', 1);
INSERT INTO `problem` VALUES (21, '腐烂的橘子', '&lt;p&gt;在给定的网格中，每个单元格可以有以下三个值之一：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;值&amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;代表空单元格；&lt;/li&gt;&lt;li&gt;值&amp;nbsp;&lt;code&gt;1&lt;/code&gt;&amp;nbsp;代表新鲜橘子；&lt;/li&gt;&lt;li&gt;值&amp;nbsp;&lt;code&gt;2&lt;/code&gt;&amp;nbsp;代表腐烂的橘子。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。&lt;/p&gt;&lt;p&gt;返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回&amp;nbsp;&lt;code&gt;-1&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png\" alt=\"\"&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;[[2,1,1],[1,1,0],[0,1,1]]\n&lt;strong&gt;输出：&lt;/strong&gt;4&lt;/pre&gt;', '2020-12-06 22:15:36', 1);
INSERT INTO `problem` VALUES (22, '最大重复子字符串', '&lt;p&gt;给你一个字符串&amp;nbsp;&lt;code&gt;sequence&lt;/code&gt;&amp;nbsp;，如果字符串&amp;nbsp;&lt;code&gt;word&lt;/code&gt;&amp;nbsp;连续重复&amp;nbsp;&lt;code&gt;k&lt;/code&gt;&amp;nbsp;次形成的字符串是&amp;nbsp;&lt;code&gt;sequence&lt;/code&gt;&amp;nbsp;的一个子字符串，那么单词&amp;nbsp;&lt;code&gt;word&lt;/code&gt;&amp;nbsp;的&amp;nbsp;&lt;strong&gt;重复值为&amp;nbsp;&lt;code&gt;k&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;&amp;nbsp;&lt;/strong&gt;。单词&amp;nbsp;&lt;code&gt;word&lt;/code&gt;&amp;nbsp;的&amp;nbsp;&lt;strong&gt;最&lt;/strong&gt;&lt;strong&gt;大重复值&lt;/strong&gt;&amp;nbsp;是单词&amp;nbsp;&lt;code&gt;word&lt;/code&gt;&amp;nbsp;在&amp;nbsp;&lt;code&gt;sequence&lt;/code&gt;&amp;nbsp;中最大的重复值。如果&amp;nbsp;&lt;code&gt;word&lt;/code&gt;&amp;nbsp;不是&amp;nbsp;&lt;code&gt;sequence&lt;/code&gt;&amp;nbsp;的子串，那么重复值&amp;nbsp;&lt;code&gt;k&lt;/code&gt;&amp;nbsp;为&amp;nbsp;&lt;code&gt;0&lt;/code&gt;&amp;nbsp;。&lt;/p&gt;&lt;p&gt;给你一个字符串&amp;nbsp;&lt;code&gt;sequence&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;word&lt;/code&gt;&amp;nbsp;，请你返回&amp;nbsp;&lt;strong&gt;最大重复值&amp;nbsp;&lt;code&gt;k&lt;/code&gt;&amp;nbsp;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;b&gt;输入：&lt;/b&gt;sequence = \"ababc\", word = \"ab\"\n&lt;b&gt;输出：&lt;/b&gt;2\n&lt;strong&gt;解释：&lt;/strong&gt;\"abab\" 是 \"&lt;strong&gt;abab&lt;/strong&gt;c\" 的子字符串。\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;b&gt;输入：&lt;/b&gt;sequence = \"ababc\", word = \"ba\"\n&lt;b&gt;输出：&lt;/b&gt;1\n&lt;strong&gt;解释：&lt;/strong&gt;\"ba\" 是 \"a&lt;strong&gt;ba&lt;/strong&gt;bc\" 的子字符串，但 \"baba\" 不是 \"ababc\" 的子字符串。&lt;/pre&gt;', '2020-12-06 22:16:03', 1);
INSERT INTO `problem` VALUES (23, '所有可能的满二叉树', '&lt;p&gt;&lt;em&gt;满二叉树&lt;/em&gt;是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。&lt;/p&gt;&lt;p&gt;返回包含&amp;nbsp;&lt;code&gt;N&lt;/code&gt;&amp;nbsp;个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。&lt;/p&gt;&lt;p&gt;答案中每个树的每个&lt;code&gt;结点&lt;/code&gt;都&lt;strong&gt;必须&lt;/strong&gt;有&amp;nbsp;&lt;code&gt;node.val=0&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;你可以按任何顺序返回树的最终列表。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;7\n&lt;strong&gt;输出：&lt;/strong&gt;[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n&lt;strong&gt;解释：&lt;/strong&gt;\n&lt;img src=\"https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/24/fivetrees.png\" alt=\"\"&gt;\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;', '2020-12-06 22:16:25', 1);
INSERT INTO `problem` VALUES (24, ' 访问所有节点的最短路径', '&lt;p&gt;给出&amp;nbsp;&lt;code&gt;graph&lt;/code&gt;&amp;nbsp;为有 N 个节点（编号为&amp;nbsp;&lt;code&gt;0, 1, 2, ..., N-1&lt;/code&gt;）的无向连通图。&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;code&gt;graph.length = N&lt;/code&gt;，且只有节点&amp;nbsp;&lt;code&gt;i&lt;/code&gt;&amp;nbsp;和&amp;nbsp;&lt;code&gt;j&lt;/code&gt;&amp;nbsp;连通时，&lt;code&gt;j != i&lt;/code&gt;&amp;nbsp;在列表&amp;nbsp;&lt;code&gt;graph[i]&lt;/code&gt;&amp;nbsp;中恰好出现一次。&lt;/p&gt;&lt;p&gt;返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;ol&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;[[1,2,3],[0],[0],[0]]\n&lt;strong&gt;输出：&lt;/strong&gt;4\n&lt;strong&gt;解释：&lt;/strong&gt;一个可能的路径为 [1,0,2,0,3]&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;[[1],[0,2,4],[1,3,4],[2],[1,2]]\n&lt;strong&gt;输出：&lt;/strong&gt;4\n&lt;strong&gt;解释：&lt;/strong&gt;一个可能的路径为 [0,1,4,2,3]&lt;/pre&gt;', '2020-12-06 22:16:47', 1);
INSERT INTO `problem` VALUES (25, ' 考场就座', '&lt;p&gt;在考场里，一排有&amp;nbsp;&lt;code&gt;N&lt;/code&gt;&amp;nbsp;个座位，分别编号为&amp;nbsp;&lt;code&gt;0, 1, 2, ..., N-1&lt;/code&gt;&amp;nbsp;。&lt;/p&gt;&lt;p&gt;当学生进入考场后，他必须坐在能够使他与离他最近的人之间的距离达到最大化的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)&lt;/p&gt;&lt;p&gt;返回&amp;nbsp;&lt;code&gt;ExamRoom(int N)&lt;/code&gt;&amp;nbsp;类，它有两个公开的函数：其中，函数&amp;nbsp;&lt;code&gt;ExamRoom.seat()&lt;/code&gt;&amp;nbsp;会返回一个&amp;nbsp;&lt;code&gt;int&lt;/code&gt;&amp;nbsp;（整型数据），代表学生坐的位置；函数&amp;nbsp;&lt;code&gt;ExamRoom.leave(int p)&lt;/code&gt;&amp;nbsp;代表坐在座位&amp;nbsp;&lt;code&gt;p&lt;/code&gt;&amp;nbsp;上的学生现在离开了考场。每次调用&amp;nbsp;&lt;code&gt;ExamRoom.leave(p)&lt;/code&gt;&amp;nbsp;时都保证有学生坐在座位&amp;nbsp;&lt;code&gt;p&lt;/code&gt;&amp;nbsp;上。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;[\"ExamRoom\",\"seat\",\"seat\",\"seat\",\"seat\",\"leave\",\"seat\"], [[10],[],[],[],[],[4],[]]\n&lt;strong&gt;输出：&lt;/strong&gt;[null,0,9,4,2,null,5]\n&lt;strong&gt;解释：&lt;/strong&gt;\nExamRoom(10) -&amp;gt; null\nseat() -&amp;gt; 0，没有人在考场里，那么学生坐在 0 号座位上。\nseat() -&amp;gt; 9，学生最后坐在 9 号座位上。\nseat() -&amp;gt; 4，学生最后坐在 4 号座位上。\nseat() -&amp;gt; 2，学生最后坐在 2 号座位上。\nleave(4) -&amp;gt; null\nseat() -&amp;gt; 5，学生最后坐在 5 号座位上。\n&lt;/pre&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;', '2020-12-06 22:17:06', 1);
INSERT INTO `problem` VALUES (26, '超级洗衣机', '&lt;p&gt;假设有&amp;nbsp;&lt;strong&gt;n&amp;nbsp;&lt;/strong&gt;台超级洗衣机放在同一排上。开始的时候，每台洗衣机内可能有一定量的衣服，也可能是空的。&lt;/p&gt;&lt;p&gt;在&lt;strong&gt;每一步操作&lt;/strong&gt;中，你可以选择&lt;strong&gt;任意 m&amp;nbsp;&lt;/strong&gt;（1 ≤ m ≤ n）&amp;nbsp;台洗衣机，与此&lt;strong&gt;同时&lt;/strong&gt;将每台洗衣机的&lt;strong&gt;一件衣服&lt;/strong&gt;送到相邻的一台洗衣机。&lt;/p&gt;&lt;p&gt;给定一个非负整数数组代表从左至右每台洗衣机中的衣物数量，请给出能让所有洗衣机中剩下的衣物的数量相等的&lt;strong&gt;最少的操作步数&lt;/strong&gt;。如果不能使每台洗衣机中衣物的数量相等，则返回 -1。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入:&lt;/strong&gt; [1,0,5]\n\n&lt;strong&gt;输出:&lt;/strong&gt; 3\n\n&lt;strong&gt;解释:&lt;/strong&gt; \n第一步:    1     0 &amp;lt;-- 5    =&amp;gt;    1     1     4\n第二步:    1 &amp;lt;-- 1 &amp;lt;-- 4    =&amp;gt;    2     1     3    \n第三步:    2     1 &amp;lt;-- 3    =&amp;gt;    2     2     2   &lt;/pre&gt;', '2020-12-06 22:17:25', 1);
INSERT INTO `problem` VALUES (27, '扁平化嵌套列表迭代器', '&lt;p&gt;给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。&lt;/p&gt;&lt;p&gt;列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入: &lt;/strong&gt;[[1,1],2,[1,1]]\n&lt;strong&gt;输出: &lt;/strong&gt;[1,1,2,1,1]\n&lt;strong&gt;解释: &lt;/strong&gt;通过重复调用&amp;nbsp;&lt;em&gt;next &lt;/em&gt;直到&amp;nbsp;&lt;em&gt;hasNex&lt;/em&gt;t 返回 false，&lt;em&gt;next&amp;nbsp;&lt;/em&gt;返回的元素的顺序应该是: &lt;code&gt;[1,1,2,1,1]&lt;/code&gt;。&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入: &lt;/strong&gt;[1,[4,[6]]]\n&lt;strong&gt;输出: &lt;/strong&gt;[1,4,6]\n&lt;strong&gt;解释: &lt;/strong&gt;通过重复调用&amp;nbsp;&lt;em&gt;next&amp;nbsp;&lt;/em&gt;直到&amp;nbsp;&lt;em&gt;hasNex&lt;/em&gt;t 返回 false，&lt;em&gt;next&amp;nbsp;&lt;/em&gt;返回的元素的顺序应该是: &lt;code&gt;[1,4,6]&lt;/code&gt;。&lt;/pre&gt;', '2020-12-06 22:17:44', 1);
INSERT INTO `problem` VALUES (28, '给定数字能组成的最大时间', '&lt;p&gt;给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。&lt;/p&gt;&lt;p&gt;24 小时格式为&amp;nbsp;&lt;code&gt;\"HH:MM\"&lt;/code&gt;&amp;nbsp;，其中&amp;nbsp;&lt;code&gt;HH&lt;/code&gt;&amp;nbsp;在&amp;nbsp;&lt;code&gt;00&lt;/code&gt;&amp;nbsp;到&amp;nbsp;&lt;code&gt;23&lt;/code&gt;&amp;nbsp;之间，&lt;code&gt;MM&lt;/code&gt;&amp;nbsp;在&amp;nbsp;&lt;code&gt;00&lt;/code&gt;&amp;nbsp;到&amp;nbsp;&lt;code&gt;59&lt;/code&gt;&amp;nbsp;之间。最小的 24 小时制时间是&amp;nbsp;&lt;code&gt;00:00&lt;/code&gt;&amp;nbsp;，而最大的是&amp;nbsp;&lt;code&gt;23:59&lt;/code&gt;&amp;nbsp;。从 00:00 （午夜）开始算起，过得越久，时间越大。&lt;/p&gt;&lt;p&gt;以长度为 5 的字符串，按&amp;nbsp;&lt;code&gt;\"HH:MM\"&lt;/code&gt;&amp;nbsp;格式返回答案。如果不能确定有效时间，则返回空字符串。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;arr = [1,2,3,4]\n&lt;strong&gt;输出：&lt;/strong&gt;\"23:41\"\n&lt;strong&gt;解释：&lt;/strong&gt;有效的 24 小时制时间是 \"12:34\"，\"12:43\"，\"13:24\"，\"13:42\"，\"14:23\"，\"14:32\"，\"21:34\"，\"21:43\"，\"23:14\" 和 \"23:41\" 。这些时间中，\"23:41\" 是最大时间。\n&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;strong&gt;输入：&lt;/strong&gt;arr = [5,5,5,5]\n&lt;strong&gt;输出：&lt;/strong&gt;\"\"\n&lt;strong&gt;解释：&lt;/strong&gt;不存在有效的 24 小时制时间，因为 \"55:55\" 无效。&lt;/pre&gt;', '2020-12-06 22:18:01', 1);
INSERT INTO `problem` VALUES (30, '快速排序', '&lt;p&gt;快速排序&lt;/p&gt;', '2020-12-08 22:04:15', 1);

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int(10) UNSIGNED NOT NULL AUTO_INCREMENT,
  `username` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `password` varchar(30) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `role` int(2) NULL DEFAULT NULL,
  `status` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '正常',
  `email` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'laozhou', 'asd123', 1, '1', '1728945207@qq.com');
INSERT INTO `user` VALUES (2, 'zhangsan', 'asd123', 0, '1', '110110@qq.com');
INSERT INTO `user` VALUES (3, 'lilonghai', 'asd123', 1, '0', '12312312asd@apple.com');
INSERT INTO `user` VALUES (4, 'asdj', 'asdasd', 0, '1', '12312@qq.com');
INSERT INTO `user` VALUES (5, 'duanqiwei', 'asd123', 0, '1', 'duanqiwei@qq.com');
INSERT INTO `user` VALUES (6, 'hahaha', 'asd123', 0, '1', '123812301@qq.com');
INSERT INTO `user` VALUES (7, 'zhongyi', 'asd123', 0, '1', '112832137@qq.com');

SET FOREIGN_KEY_CHECKS = 1;
